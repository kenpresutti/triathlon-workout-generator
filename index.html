import React, { useState } from 'react';
import { Download, Zap, Activity } from 'lucide-react';

export default function WorkoutGenerator() {
  const [ftp, setFtp] = useState(226);
  const [fthr, setFthr] = useState(185);
  const [workoutDescription, setWorkoutDescription] = useState('');
  const [workout, setWorkout] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [groupIntervals, setGroupIntervals] = useState(false);
  const [includeLastRecovery, setIncludeLastRecovery] = useState(false);

  // Zone calculations based on FTP
  const calculateZones = (ftpValue) => {
    return {
      z1: { min: Math.round(ftpValue * 0.50), max: Math.round(ftpValue * 0.60), name: 'Active Recovery' },
      z2: { min: Math.round(ftpValue * 0.60), max: Math.round(ftpValue * 0.75), name: 'Endurance' },
      z3: { min: Math.round(ftpValue * 0.75), max: Math.round(ftpValue * 0.90), name: 'Tempo' },
      z4: { min: Math.round(ftpValue * 0.90), max: Math.round(ftpValue * 1.05), name: 'Threshold' },
      z5: { min: Math.round(ftpValue * 1.05), max: Math.round(ftpValue * 1.20), name: 'VO2 Max' },
      z6: { min: Math.round(ftpValue * 1.20), max: Math.round(ftpValue * 1.50), name: 'Anaerobic' }
    };
  };

  const zones = calculateZones(ftp);

  const generateWorkout = async () => {
    if (!workoutDescription.trim()) {
      setError('Please enter a workout description');
      return;
    }

    setLoading(true);
    setError(null);

    try {
      const prompt = `You are a triathlon workout parser. Given an FTP of ${ftp}W and these power zones:
- Z1: ${zones.z1.min}-${zones.z1.max}W (Active Recovery)
- Z2: ${zones.z2.min}-${zones.z2.max}W (Endurance)
- Z3: ${zones.z3.min}-${zones.z3.max}W (Tempo)
- Z4: ${zones.z4.min}-${zones.z4.max}W (Threshold)
- Z5: ${zones.z5.min}-${zones.z5.max}W (VO2 Max)
- Z6: ${zones.z6.min}-${zones.z6.max}W (Anaerobic)

Parse this workout description: "${workoutDescription}"

IMPORTANT RULES:
1. When intervals are described as "each slightly higher", distribute them evenly across the zone (low, mid, high portions).
2. When you see "4x30sec zone 4 with 30 rest", create 4 segments of 30sec at Z4, with 30sec rest segments at Z1 between them.
3. Rest periods should always be at Z1 (active recovery).
4. Convert "mins" or "min" to seconds (multiply by 60).
5. Convert "sec" to seconds as-is.
6. Ignore cadence instructions like "at 70rpm" or "at 60rpm" - just focus on power and duration.
7. For intervals like "3 x 7 min @ Z4", create 3 segments of 7 minutes each at Z4, with rest periods between them if specified.

Return ONLY a valid JSON object with this exact structure (no markdown, no code blocks, no explanation):
{
  "name": "Custom Workout",
  "description": "Generated workout",
  "segments": [
    {
      "type": "warmup",
      "duration": 600,
      "power": 120,
      "zone": "Z1",
      "description": "Warm up"
    }
  ]
}

Make sure every segment has type, duration (in seconds), power (in watts), zone, and description fields.`;

      const response = await fetch('https://api.anthropic.com/v1/messages', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: 'claude-sonnet-4-20250514',
          max_tokens: 2000,
          messages: [
            { role: 'user', content: prompt }
          ]
        })
      });

      if (!response.ok) {
        const errorData = await response.text();
        console.error('API Error:', errorData);
        throw new Error(`API returned ${response.status}: ${errorData}`);
      }

      const data = await response.json();
      console.log('API Response:', data);
      
      const content = data.content.find(item => item.type === 'text')?.text || '';
      console.log('Content:', content);
      
      // Clean up the response - remove markdown code blocks if present
      let cleanContent = content.replace(/```json\n?|\n?```/g, '').trim();
      
      // Try to find JSON in the response if it's wrapped in other text
      const jsonMatch = cleanContent.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        cleanContent = jsonMatch[0];
      }
      
      console.log('Clean content:', cleanContent);
      
      const workoutData = JSON.parse(cleanContent);
      
      // Validate the workout data
      if (!workoutData.segments || !Array.isArray(workoutData.segments)) {
        throw new Error('Invalid workout format: missing segments array');
      }
      
      setWorkout(workoutData);
    } catch (err) {
      console.error('Error details:', err);
      setError(`Failed to parse workout: ${err.message}. Check console for details.`);
    } finally {
      setLoading(false);
    }
  };

  const exportZWO = () => {
    if (!workout) return;

    const xml = `<?xml version="1.0" encoding="UTF-8"?>
<workout_file>
  <name>${workout.name}</name>
  <description>${workout.description}</description>
  <sportType>bike</sportType>
  <tags></tags>
  <workout>
${workout.segments.map((seg, idx) => {
  const powerPercent = (seg.power / ftp).toFixed(2);
  return `    <${seg.type} Duration="${seg.duration}" PowerLow="${powerPercent}" PowerHigh="${powerPercent}">
      <textevent timeoffset="0" message="${seg.description}"/>
    </${seg.type}>`;
}).join('\n')}
  </workout>
</workout_file>`;

    const blob = new Blob([xml], { type: 'application/xml' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${workout.name.replace(/\s+/g, '_')}.zwo`;
    a.click();
    URL.revokeObjectURL(url);
  };

  const exportERG = () => {
    if (!workout) return;

    let totalSeconds = 0;
    const ergLines = workout.segments.map(seg => {
      const start = totalSeconds;
      totalSeconds += seg.duration;
      return `${start}\t${seg.power}\n${totalSeconds}\t${seg.power}`;
    }).join('\n');

    const erg = `[COURSE HEADER]
VERSION = 2
UNITS = ENGLISH
DESCRIPTION = ${workout.name}
FILE NAME = ${workout.name}
MINUTES WATTS
[END COURSE HEADER]
[COURSE DATA]
${ergLines}
[END COURSE DATA]`;

    const blob = new Blob([erg], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${workout.name.replace(/\s+/g, '_')}.erg`;
    a.click();
    URL.revokeObjectURL(url);
  };

  const exportMRC = () => {
    if (!workout) return;

    let totalMinutes = 0;
    const mrcLines = workout.segments.map(seg => {
      const start = totalMinutes;
      const durationMin = (seg.duration / 60).toFixed(2);
      totalMinutes = parseFloat((totalMinutes + parseFloat(durationMin)).toFixed(2));
      const powerPercent = ((seg.power / ftp) * 100).toFixed(0);
      return `${start.toFixed(2)}\t${powerPercent}\n${totalMinutes.toFixed(2)}\t${powerPercent}`;
    }).join('\n');

    const mrc = `[COURSE HEADER]
VERSION = 2
UNITS = ENGLISH
DESCRIPTION = ${workout.name}
FILE NAME = ${workout.name}
MINUTES PERCENT
[END COURSE HEADER]
[COURSE DATA]
${mrcLines}
[END COURSE DATA]`;

    const blob = new Blob([mrc], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${workout.name.replace(/\s+/g, '_')}.mrc`;
    a.click();
    URL.revokeObjectURL(url);
  };

  const getTotalDuration = () => {
    if (!workout) return 0;
    let total = workout.segments.reduce((sum, seg) => sum + seg.duration, 0);
    
    // Add extra recovery time if "include last recovery" is checked and intervals are grouped
    if (groupIntervals && includeLastRecovery) {
      const grouped = groupIntervalSets(workout.segments);
      grouped.forEach(item => {
        if (item.isGroup && item.recovery) {
          // Add one more recovery duration for each grouped set
          total += item.recovery.duration;
        }
      });
    }
    
    return total;
  };

  const formatDuration = (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  const groupIntervalSets = (segments) => {
    if (!groupIntervals) return segments.map((s, idx) => ({ ...s, isGroup: false, originalIndex: idx }));

    const grouped = [];
    let i = 0;

    while (i < segments.length) {
      const current = segments[i];
      
      // Check if this might be the start of an interval set
      if (current.type === 'interval') {
        // Collect all consecutive intervals that look similar
        const intervals = [current];
        const intervalIndices = [i];
        const recoveries = [];
        const recoveryIndices = [];
        let j = i + 1;
        
        // Check if there's a recovery after first interval
        let hasRecovery = false;
        if (j < segments.length && segments[j].zone === 'Z1') {
          recoveries.push(segments[j]);
          recoveryIndices.push(j);
          hasRecovery = true;
          j++;
        }
        
        // Continue looking for more intervals in this set
        while (j < segments.length) {
          const potentialInterval = segments[j];
          
          // Check if this looks like part of the same interval set
          if (potentialInterval.type === 'interval' &&
              potentialInterval.zone === current.zone &&
              Math.abs(potentialInterval.duration - current.duration) <= 30) {
            
            intervals.push(potentialInterval);
            intervalIndices.push(j);
            j++;
            
            // Check for recovery after this interval
            if (j < segments.length && segments[j].zone === 'Z1' && 
                segments[j].duration <= current.duration * 2) {
              recoveries.push(segments[j]);
              recoveryIndices.push(j);
              j++;
            }
          } else {
            break;
          }
        }
        
        // If we found multiple intervals, group them
        if (intervals.length >= 2) {
          // Calculate power range across all intervals
          const minPower = Math.min(...intervals.map(int => int.power));
          const maxPower = Math.max(...intervals.map(int => int.power));
          
          // Use first recovery as template (if exists)
          const recoveryTemplate = recoveries.length > 0 ? recoveries[0] : null;
          const avgRecoveryPower = recoveries.length > 0
            ? Math.round(recoveries.reduce((sum, r) => sum + r.power, 0) / recoveries.length)
            : 0;
          
          grouped.push({
            isGroup: true,
            reps: intervals.length,
            active: {
              ...current,
              powerMin: minPower,
              powerMax: maxPower,
              description: current.description.replace(/Interval \d+ of \d+ - /, '')
            },
            recovery: recoveryTemplate ? {
              ...recoveryTemplate,
              power: avgRecoveryPower
            } : null,
            originalIndices: [...intervalIndices, ...recoveryIndices],
            totalDuration: intervals.reduce((sum, int) => sum + int.duration, 0) + 
                          recoveries.reduce((sum, rec) => sum + rec.duration, 0)
          });
          i = j;
          continue;
        }
      }
      
      // Not part of a group, add as individual segment
      grouped.push({ ...current, isGroup: false, originalIndex: i });
      i++;
    }

    return grouped;
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-6">
      <div className="max-w-6xl mx-auto">
        <div className="bg-white rounded-lg shadow-xl p-8 mb-6">
          <div className="flex items-center gap-3 mb-6">
            <Zap className="text-indigo-600" size={32} />
            <h1 className="text-3xl font-bold text-gray-800">Triathlon Workout Generator</h1>
          </div>

          {/* FTP/FTHR Inputs */}
          <div className="grid grid-cols-2 gap-4 mb-6">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">
                FTP (Watts)
              </label>
              <input
                type="number"
                value={ftp}
                onChange={(e) => setFtp(parseInt(e.target.value) || 0)}
                className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent"
              />
            </div>
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">
                FTHR (BPM)
              </label>
              <input
                type="number"
                value={fthr}
                onChange={(e) => setFthr(parseInt(e.target.value) || 0)}
                className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent"
              />
            </div>
          </div>

          {/* Power Zones Display */}
          <div className="mb-6 p-4 bg-gray-50 rounded-lg">
            <h3 className="text-sm font-semibold text-gray-700 mb-3">Your Power Zones</h3>
            <div className="grid grid-cols-3 gap-3">
              {Object.entries(zones).map(([key, zone]) => (
                <div key={key} className="text-xs">
                  <span className="font-semibold text-indigo-600">{key.toUpperCase()}:</span>{' '}
                  {zone.min}-{zone.max}W
                  <div className="text-gray-500">{zone.name}</div>
                </div>
              ))}
            </div>
          </div>

          {/* Workout Description */}
          <div className="mb-6">
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Describe Your Workout
            </label>
            <textarea
              value={workoutDescription}
              onChange={(e) => setWorkoutDescription(e.target.value)}
              placeholder="Example: 10 minute warm up with 2 minutes in zone 1, 5min in zone 2, and 3 min in zone 3. Then do 5x3 intervals at zone 4, each interval slightly higher than the next, followed by a 5min cool down."
              className="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent h-32"
            />
          </div>

          {error && (
            <div className="mb-4 p-3 bg-red-50 border border-red-200 text-red-700 rounded-lg">
              {error}
            </div>
          )}

          <button
            onClick={generateWorkout}
            disabled={loading}
            className="w-full bg-indigo-600 text-white py-3 rounded-lg font-semibold hover:bg-indigo-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors flex items-center justify-center gap-2"
          >
            {loading ? (
              <>
                <Activity className="animate-spin" size={20} />
                Generating Workout...
              </>
            ) : (
              <>
                <Zap size={20} />
                Generate Workout
              </>
            )}
          </button>
        </div>

        {/* Workout Preview */}
        {workout && (
          <div className="bg-white rounded-lg shadow-xl p-8">
            <div className="flex items-center justify-between mb-6">
              <div>
                <h2 className="text-2xl font-bold text-gray-800">{workout.name}</h2>
                <p className="text-gray-600">{workout.description}</p>
                <p className="text-sm text-gray-500 mt-1">
                  Total Duration: {formatDuration(getTotalDuration())}
                </p>
              </div>
              <div className="flex gap-2">
                <button
                  onClick={exportZWO}
                  className="flex items-center gap-2 px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors"
                >
                  <Download size={18} />
                  .ZWO
                </button>
                <button
                  onClick={exportERG}
                  className="flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
                >
                  <Download size={18} />
                  .ERG
                </button>
                <button
                  onClick={exportMRC}
                  className="flex items-center gap-2 px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors"
                >
                  <Download size={18} />
                  .MRC
                </button>
              </div>
            </div>

            {/* Visual Workout Chart */}
            <div className="mb-8 p-6 bg-gray-50 rounded-lg">
              <h3 className="text-lg font-semibold text-gray-700 mb-4">Workout Structure</h3>
              <div className="relative h-48 bg-white rounded border border-gray-200 overflow-hidden">
                {/* Y-axis labels */}
                <div className="absolute left-0 top-0 bottom-0 w-12 flex flex-col justify-between text-xs text-gray-500 py-2">
                  <div>Z6</div>
                  <div>Z5</div>
                  <div>Z4</div>
                  <div>Z3</div>
                  <div>Z2</div>
                  <div>Z1</div>
                </div>
                
                {/* Workout bars */}
                <div className="absolute left-12 right-0 top-0 bottom-0 flex items-end">
                  {(() => {
                    // Build chart segments
                    const chartSegments = [];
                    
                    if (groupIntervals && includeLastRecovery) {
                      const grouped = groupIntervalSets(workout.segments);
                      let segmentIdx = 0;
                      
                      grouped.forEach(item => {
                        if (item.isGroup) {
                          // Add all original segments from this group
                          const numSegmentsInGroup = item.originalIndices.length;
                          for (let i = 0; i < numSegmentsInGroup; i++) {
                            chartSegments.push(workout.segments[segmentIdx]);
                            segmentIdx++;
                          }
                          
                          // Add ADDITIONAL final recovery after the group
                          if (item.recovery) {
                            chartSegments.push({
                              ...item.recovery,
                              description: 'Final recovery after interval set'
                            });
                          }
                        } else {
                          // Add individual segment
                          chartSegments.push(workout.segments[segmentIdx]);
                          segmentIdx++;
                        }
                      });
                      
                      return chartSegments;
                    } else {
                      return workout.segments;
                    }
                  })().map((segment, idx) => {
                    const totalDuration = getTotalDuration();
                    const widthPercent = (segment.duration / totalDuration) * 100;
                    
                    // Calculate height based on zone
                    const zoneNum = parseInt(segment.zone.replace('Z', ''));
                    const heightPercent = (zoneNum / 6) * 100;
                    
                    // Color based on zone
                    const colors = {
                      1: 'bg-blue-200',
                      2: 'bg-green-400',
                      3: 'bg-yellow-400',
                      4: 'bg-orange-400',
                      5: 'bg-red-400',
                      6: 'bg-red-600'
                    };
                    
                    return (
                      <div
                        key={idx}
                        className={`${colors[zoneNum]} border-r border-gray-300 hover:opacity-80 transition-opacity cursor-pointer relative group`}
                        style={{
                          width: `${widthPercent}%`,
                          height: `${heightPercent}%`
                        }}
                        title={`${segment.description} - ${formatDuration(segment.duration)}`}
                      >
                        {/* Tooltip on hover */}
                        <div className="absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 hidden group-hover:block bg-gray-800 text-white text-xs rounded py-1 px-2 whitespace-nowrap z-10">
                          {segment.zone}: {formatDuration(segment.duration)}
                        </div>
                      </div>
                    );
                  })}
                </div>
              </div>
              
              {/* Time scale below */}
              <div className="mt-2 ml-12 flex justify-between text-xs text-gray-500">
                <span>0:00</span>
                <span>{formatDuration(getTotalDuration())}</span>
              </div>
            </div>

            {/* Workout Segments */}
            <div className="mb-6">
              <div className="flex items-center gap-3 mb-4">
                <h3 className="text-lg font-semibold text-gray-700">Intervals</h3>
                <label className="flex items-center gap-2 cursor-pointer">
                  <input
                    type="checkbox"
                    checked={groupIntervals}
                    onChange={(e) => setGroupIntervals(e.target.checked)}
                    className="w-4 h-4 text-indigo-600 rounded focus:ring-indigo-500"
                  />
                  <span className="text-sm text-gray-600">Group interval sets</span>
                </label>
                {groupIntervals && (
                  <label className="flex items-center gap-2 cursor-pointer">
                    <input
                      type="checkbox"
                      checked={includeLastRecovery}
                      onChange={(e) => setIncludeLastRecovery(e.target.checked)}
                      className="w-4 h-4 text-indigo-600 rounded focus:ring-indigo-500"
                    />
                    <span className="text-sm text-gray-600">Include recovery after last interval</span>
                  </label>
                )}
              </div>

              <div className="space-y-3">
                {groupIntervalSets(workout.segments).map((item, idx) => {
                  if (item.isGroup) {
                    // Grouped interval set
                    const powerRange = item.active.powerMin === item.active.powerMax 
                      ? `${item.active.powerMin}W`
                      : `${item.active.powerMin} - ${item.active.powerMax} W`;
                    const percentRange = item.active.powerMin === item.active.powerMax
                      ? `${((item.active.powerMin / ftp) * 100).toFixed(0)}% CP`
                      : `${((item.active.powerMin / ftp) * 100).toFixed(0)} - ${((item.active.powerMax / ftp) * 100).toFixed(0)}% CP`;
                    
                    return (
                      <div key={idx} className="bg-gray-50 rounded-lg border border-gray-200 overflow-hidden">
                        {/* Active interval */}
                        <div className="flex items-center gap-4 p-4 border-l-4 border-indigo-500">
                          <div className="flex-shrink-0 w-20 text-center">
                            <div className="text-2xl font-bold text-indigo-600">
                              {formatDuration(item.active.duration)}
                            </div>
                            <div className="text-xs text-gray-500">Active</div>
                          </div>
                          <div className="flex-grow">
                            <div className="font-semibold text-gray-800">{item.active.description}</div>
                            <div className="text-sm text-gray-600">
                              {powerRange} • {item.active.zone} • {percentRange}
                            </div>
                          </div>
                          <div className="flex-shrink-0">
                            <div className="px-3 py-1 bg-yellow-400 text-gray-800 rounded-full text-sm font-bold">
                              {item.reps}x
                            </div>
                          </div>
                        </div>
                        
                        {/* Recovery interval (nested) - only if recovery exists */}
                        {item.recovery && (
                          <div className="flex items-center gap-4 p-4 pl-8 bg-white border-l-4 border-gray-300 ml-4">
                            <div className="flex-shrink-0 w-20 text-center">
                              <div className="text-xl font-bold text-gray-600">
                                {formatDuration(item.recovery.duration)}
                              </div>
                              <div className="text-xs text-gray-500">Intra-Recovery</div>
                            </div>
                            <div className="flex-grow">
                              <div className="font-semibold text-gray-700">{item.recovery.description}</div>
                              <div className="text-sm text-gray-600">
                                {item.recovery.power}W • {item.recovery.zone} • {((item.recovery.power / ftp) * 100).toFixed(0)}% CP
                              </div>
                            </div>
                          </div>
                        )}
                        
                        {/* Final recovery after last interval - only if checkbox is checked and recovery exists */}
                        {includeLastRecovery && item.recovery && (
                          <div className="flex items-center gap-4 p-4 bg-gray-50 border-l-4 border-gray-400">
                            <div className="flex-shrink-0 w-20 text-center">
                              <div className="text-xl font-bold text-gray-600">
                                {formatDuration(item.recovery.duration)}
                              </div>
                              <div className="text-xs text-gray-500">Final Recovery</div>
                            </div>
                            <div className="flex-grow">
                              <div className="font-semibold text-gray-700">Recovery after last interval</div>
                              <div className="text-sm text-gray-600">
                                {item.recovery.power}W • {item.recovery.zone} • {((item.recovery.power / ftp) * 100).toFixed(0)}% CP
                              </div>
                            </div>
                          </div>
                        )}
                      </div>
                    );
                  } else {
                    // Individual segment
                    const segment = item;
                    const segmentType = segment.type === 'cooldown' ? 'Cool Down' : 
                                      segment.type === 'warmup' ? 'Warm Up' : 
                                      segment.type;
                    
                    return (
                      <div
                        key={idx}
                        className="flex items-center gap-4 p-4 bg-gray-50 rounded-lg border-l-4 border-indigo-500"
                      >
                        <div className="flex-shrink-0 w-20 text-center">
                          <div className="text-2xl font-bold text-indigo-600">
                            {formatDuration(segment.duration)}
                          </div>
                          <div className="text-xs text-gray-500 capitalize">{segmentType}</div>
                        </div>
                        <div className="flex-grow">
                          <div className="font-semibold text-gray-800">{segment.description}</div>
                          <div className="text-sm text-gray-600">
                            {segment.power}W • {segment.zone} • {((segment.power / ftp) * 100).toFixed(0)}% CP
                          </div>
                        </div>
                        <div className="flex-shrink-0">
                          <div className="px-3 py-1 bg-indigo-100 text-indigo-800 rounded-full text-sm font-medium">
                            {segment.zone}
                          </div>
                        </div>
                      </div>
                    );
                  }
                })}
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}